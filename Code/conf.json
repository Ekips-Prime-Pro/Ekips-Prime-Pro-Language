{
    "version": "2.3.5",
    "calibrate" : "\nasync def calibrate(speed=1000, acceleration=1000):\n    if (distance_sensor.distance(port.C) < 110):\n        print('Calibration not possible! | Distance to small!')\n    elif (distance_sensor.distance(port.C) > 110):\n        try:\n            await drive(-1, 14, speed, acceleration)\n            distance0 = distance_sensor.distance(port.C)\n            await drive(10, 14, speed, acceleration)\n            distance1 = distance_sensor.distance(port.C)\n            calibration = distance0 - distance1\n            #print('Calibration done!')\n            print(calibration)\n            wait(0.5)\n        except:\n            print('Calibration not possible! | Error!')",
    "module": "\nasync def module(degrees=0, speed=1110, acceleration=10000):\n    if (degrees > 0):\n        await motor.run_for_degrees(motor_module, degrees, speed, acceleration=acceleration)\n    elif (degrees < 0):\n        await motor.run_for_degrees(motor_module, degrees, speed, acceleration=acceleration)\n    elif (degrees == 0):\n        print('Error')",
    "motor": "\nasync def drive(distance=0, multiplier=14, speed=1000, acceleration=1000):\n    if (distance > 0):\n        degrees = (distance * calibration)\n        await motor_pair.move_for_degrees(pair, degrees, 0, velocity=speed, acceleration=acceleration)\n    elif (distance < 0):\n        degrees = distance * calibration\n        await motor_pair.move_for_degrees(pair, degrees, 0, velocity=speed, acceleration=acceleration)\n    elif (distance == 0):\n        print('Null Value Error')\nasync def tank(degrees=0, left_speed=1000, right_speed=1000, acceleration=1000):\n    #180 degrees = 90 Grad\n    if (degrees > 0):\n        await motor_pair.move_tank_for_degrees(pair, -degrees, left_speed, -right_speed, acceleration=acceleration)\n    elif (degrees < 0):\n        await motor_pair.move_tank_for_degrees(pair, degrees, -left_speed, right_speed, acceleration=acceleration)\n    elif (degrees == 0):\n        print('Null Value Error')\nasync def obstacle(distance=0, speed=1000, acceleration=1000):\n    if (distance > 0):\n        while distance_sensor.distance(port.C) > distance:\n            await drive(2, 14, speed, acceleration)\n        print('Obstacle detected!')\n    elif (distance <= 0):\n        print('Null Value Error')",
    "sensor": "\nasync def switch(switch=False):\n    while switch == False:\n        if (force_sensor.force(force_module) >= 50):\n            switch = True\n            return True",
    "variables": "\npair = motor_pair.PAIR_1\nmotor_pair.pair(pair, port.F, port.B)\nmotor_module = port.E\nmotor_module1 = port.A\nforce_module = port.D\ncalibration = 1\naverage = 111\ntimes = 1\ntimes1 = 1\naverage_calibration = []\naverage_obs = []",
    "ai": "\ndata = [\n    {'Calibration': 1.0, 'Akku': 100, 'Wheelusage': 1.0, 'Multiplication': 1.00},\n    {'Calibration': 1.0, 'Akku': 900, 'Wheelusage': 0.9, 'Multiplication': 1.10},\n    {'Calibration': 1.0, 'Akku': 800, 'Wheelusage': 0.8, 'Multiplication': 1.25},\n    {'Calibration': 0.9, 'Akku': 100, 'Wheelusage': 1.0, 'Multiplication': 1.10},\n    {'Calibration': 1.1, 'Akku': 100, 'Wheelusage': 1.0, 'Multiplication': 0.95}\n]\ndef euclidean_distance(point1, point2):\n    multiplication = 0.0\n    for key in point1:\n        if key != 'Multiplication':\n            multiplication += (point1[key] - point2[key]) ** 2\n    return math.sqrt(multiplication)\ndef knn_predict(data, new_data_point, k=3):\n    multiplication = []\n    for item in data:\n        dist = euclidean_distance(new_data_point, item)\n        multiplication.append((dist, item['Multiplication']))\n    multiplication.sort(key=lambda x: x[0])\n    neighbors = multiplication[:k]\n    total_multiplication = sum(neighbor[1] for neighbor in neighbors)\n    predicted_multiplication = total_multiplication / k\n    calibration = predicted_multiplication\n    return predicted_multiplication",
    "switch": "\nasync def switch(switch=False):\n    while switch == False:\n        if (force_sensor.force(force_module) >= 50):\n            switch = True\n            return True"
}