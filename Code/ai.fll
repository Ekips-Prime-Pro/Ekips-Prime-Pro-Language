
# Bsp: Datensatz (Bitte bearbeiten f체r die von Ihnen gemessene Werte)
# F체r die kalibrierung bitte einfach die eingebaute Funktion calibrate aus und lassen sie sich das Ergebnis ausgeben.
# Die Reifennutzung ver채ndert sich f체r jeden Run um -0.05
# Der Batterieladestand muss jedesmal gesondert abgelesen werden
# Wenn sie diese Schritte einhalten kann die KI / das KNN richtig funktionieren
data = [
    {'Kalibrierung': 1.0, 'Batterieladestand': 100, 'Reifennutzung': 1.0, 'Multiplikation': 1.00},
    {'Kalibrierung': 1.0, 'Batterieladestand': 90, 'Reifennutzung': 0.9, 'Multiplikation': 1.10},
    {'Kalibrierung': 1.0, 'Batterieladestand': 80, 'Reifennutzung': 0.8, 'Multiplikation': 1.25},
    {'Kalibrierung': 0.9, 'Batterieladestand': 100, 'Reifennutzung': 1.0, 'Multiplikation': 1.10},
    {'Kalibrierung': 1.1, 'Batterieladestand': 100, 'Reifennutzung': 1.0, 'Multiplikation': 0.95}
]

def euclidean_distance(point1, point2):
    distance = 0.0
    for key in point1:
        if key != 'Multiplikation':
            distance += (point1[key] - point2[key]) ** 2
    return math.sqrt(distance)

def knn_predict(data, new_data_point, k=3):
    # Berechne die Distanz zwischen dem neuen Punkt und allen anderen Punkten
    distances = []
    for item in data:
        dist = euclidean_distance(new_data_point, item)
        distances.append((dist, item['Multiplikation']))

    distances.sort(key=lambda x: x[0])
    neighbors = distances[:k]

    total_distance = sum(neighbor[1] for neighbor in neighbors)
    predicted_distance = total_distance / k

    return predicted_distance

