
data = [
    {'Calibration': 1.0, 'Akku': 100, 'Wheelusage': 1.0, 'Multiplication': 1.00},
    {'Calibration': 1.0, 'Akku': 900, 'Wheelusage': 0.9, 'Multiplication': 1.10},
    {'Calibration': 1.0, 'Akku': 800, 'Wheelusage': 0.8, 'Multiplication': 1.25},
    {'Calibration': 0.9, 'Akku': 100, 'Wheelusage': 1.0, 'Multiplication': 1.10},
    {'Calibration': 1.1, 'Akku': 100, 'Wheelusage': 1.0, 'Multiplication': 0.95}
]

def euclidean_distance(point1, point2):
    multiplication = 0.0
    for key in point1:
        if key != 'Multiplication':
            multiplication += (point1[key] - point2[key]) ** 2
    return math.sqrt(multiplication)

def knn_predict(data, new_data_point, k=3):
    multiplication = []
    for item in data:
        dist = euclidean_distance(new_data_point, item)
        multiplication.append((dist, item['Multiplication']))

    multiplication.sort(key=lambda x: x[0])
    neighbors = multiplication[:k]

    total_multiplication = sum(neighbor[1] for neighbor in neighbors)
    predicted_multiplication = total_multiplication / k

    return predicted_multiplication

